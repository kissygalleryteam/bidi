/*
combined files : 

gallery/bidi/1.0/expression/parse
gallery/bidi/1.0/expression/index
gallery/bidi/1.0/models
gallery/bidi/1.0/watch/text
gallery/bidi/1.0/watch/class
gallery/bidi/1.0/watch/click
gallery/bidi/1.0/watch/select
gallery/bidi/1.0/watch/attr
gallery/bidi/1.0/watch/each
gallery/bidi/1.0/watch/radio
gallery/bidi/1.0/watch/list
gallery/bidi/1.0/watch/render
gallery/bidi/1.0/watch/value
gallery/bidi/1.0/watch/index
gallery/bidi/1.0/views
gallery/bidi/1.0/index

*/
KISSY.add('gallery/bidi/1.0/expression/parse',function(){

/* parser generated by jison 0.4.6 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parse = (function(){
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"expressions":3,"math":4,"EOF":5,"var":6,"VAR":7,"DOT":8,"||":9,"&&":10,">":11,"<":12,"==":13,">=":14,"<=":15,"!=":16,"!":17,"NUMBER":18,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",7:"VAR",8:"DOT",9:"||",10:"&&",11:">",12:"<",13:"==",14:">=",15:"<=",16:"!=",17:"!",18:"NUMBER"},
productions_: [0,[3,2],[6,1],[6,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,2],[4,1],[4,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1: return $$[$0-1]; 
break;
case 2: this.$ = { name: $$[$0], path: [] } 
break;
case 3: this.$ = { name : $$[$0-2].name, path: $$[$0-2].path.concat($$[$0]) } 
break;
case 4: this.$ = { l: $$[$0-2], r: $$[$0], operator: $$[$0-1] }; 
break;
case 5: this.$ = { l: $$[$0-2], r: $$[$0], operator: $$[$0-1] }; 
break;
case 6: this.$ = { l: $$[$0-2], r: $$[$0], operator: $$[$0-1] }; 
break;
case 7: this.$ = { l: $$[$0-2], r: $$[$0], operator: $$[$0-1] }; 
break;
case 8: this.$ = { l: $$[$0-2], r: $$[$0], operator: $$[$0-1] }; 
break;
case 9: this.$ = { l: $$[$0-2], r: $$[$0], operator: $$[$0-1] }; 
break;
case 10: this.$ = { l: $$[$0-2], r: $$[$0], operator: $$[$0-1] }; 
break;
case 11: this.$ = { l: $$[$0-2], r: $$[$0], operator: $$[$0-1] }; 
break;
case 12: this.$ = { l: $$[$0], operator: 'not' }; 
break;
case 13: this.$ = $$[$0]; 
break;
case 14: this.$ = $$[$0]; 
break;
}
},
table: [{3:1,4:2,6:4,7:[1,6],17:[1,3],18:[1,5]},{1:[3]},{5:[1,7],9:[1,8],10:[1,9],11:[1,10],12:[1,11],13:[1,12],14:[1,13],15:[1,14],16:[1,15]},{4:16,6:4,7:[1,6],17:[1,3],18:[1,5]},{5:[2,13],8:[1,17],9:[2,13],10:[2,13],11:[2,13],12:[2,13],13:[2,13],14:[2,13],15:[2,13],16:[2,13]},{5:[2,14],9:[2,14],10:[2,14],11:[2,14],12:[2,14],13:[2,14],14:[2,14],15:[2,14],16:[2,14]},{5:[2,2],8:[2,2],9:[2,2],10:[2,2],11:[2,2],12:[2,2],13:[2,2],14:[2,2],15:[2,2],16:[2,2]},{1:[2,1]},{4:18,6:4,7:[1,6],17:[1,3],18:[1,5]},{4:19,6:4,7:[1,6],17:[1,3],18:[1,5]},{4:20,6:4,7:[1,6],17:[1,3],18:[1,5]},{4:21,6:4,7:[1,6],17:[1,3],18:[1,5]},{4:22,6:4,7:[1,6],17:[1,3],18:[1,5]},{4:23,6:4,7:[1,6],17:[1,3],18:[1,5]},{4:24,6:4,7:[1,6],17:[1,3],18:[1,5]},{4:25,6:4,7:[1,6],17:[1,3],18:[1,5]},{5:[2,12],9:[2,12],10:[2,12],11:[2,12],12:[2,12],13:[2,12],14:[2,12],15:[2,12],16:[2,12]},{7:[1,26]},{5:[2,4],9:[2,4],10:[2,4],11:[1,10],12:[1,11],13:[1,12],14:[1,13],15:[1,14],16:[1,15]},{5:[2,5],9:[2,5],10:[2,5],11:[1,10],12:[1,11],13:[1,12],14:[1,13],15:[1,14],16:[1,15]},{5:[2,6],9:[2,6],10:[2,6],11:[2,6],12:[2,6],13:[2,6],14:[2,6],15:[2,6],16:[2,6]},{5:[2,7],9:[2,7],10:[2,7],11:[2,7],12:[2,7],13:[2,7],14:[2,7],15:[2,7],16:[2,7]},{5:[2,8],9:[2,8],10:[2,8],11:[2,8],12:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[2,8]},{5:[2,9],9:[2,9],10:[2,9],11:[2,9],12:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[2,9]},{5:[2,10],9:[2,10],10:[2,10],11:[2,10],12:[2,10],13:[2,10],14:[2,10],15:[2,10],16:[2,10]},{5:[2,11],9:[2,11],10:[2,11],11:[2,11],12:[2,11],13:[2,11],14:[2,11],15:[2,11],16:[2,11]},{5:[2,3],8:[2,3],9:[2,3],10:[2,3],11:[2,3],12:[2,3],13:[2,3],14:[2,3],15:[2,3],16:[2,3]}],
defaultActions: {7:[2,1]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    this.yy.parser = this;
    if (typeof this.lexer.yylloc == 'undefined') {
        this.lexer.yylloc = {};
    }
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);
    var ranges = this.lexer.options && this.lexer.options.ranges;
    if (typeof this.yy.parseError === 'function') {
        this.parseError = this.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    function lex() {
        var token;
        token = self.lexer.lex() || EOF;
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (this.lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: this.lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: this.lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(this.lexer.yytext);
            lstack.push(this.lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.2.1 */
var lexer = (function(){
var lexer = {

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input) {
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {

var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: return 18 
break;
case 1: return 7 
break;
case 2: return 8 
break;
case 3: return yy_.yytext 
break;
case 4: return yy_.yytext 
break;
case 5: return yy_.yytext 
break;
case 6: return yy_.yytext 
break;
case 7: return yy_.yytext 
break;
case 8: return yy_.yytext 
break;
case 9: return yy_.yytext 
break;
case 10: return yy_.yytext 
break;
case 11: return yy_.yytext 
break;
case 12: /*ignore whitespace*/ 
break;
case 13: return 5; 
break;
}
},
rules: [/^(?:\d+)/,/^(?:[\$\w]+)/,/^(?:\.(?=[\$\w]))/,/^(?:<=)/,/^(?:>=)/,/^(?:==)/,/^(?:>)/,/^(?:<)/,/^(?:!=)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:!)/,/^(?:\s+)/,/^(?:$)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"inclusive":true}}
};
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parse;
exports.Parser = parse.Parser;
exports.parse = function () { return parse.parse.apply(parse, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
return parse; 
});

KISSY.add('gallery/bidi/1.0/expression/index',function(S, Parse){

  "use strict";

  // 模型求值运算，支持以下表达式
  // 1. 基本属性求值，attrname  attrname.key attrname.length
  // 2. 其他运算表达式，支持逻辑运算、比较运算 !a ,  a || b , a && b
  //    a > b , a > 1, a < b, a == b, a >= b
  // 3. 一起基本求值混合，不支持括号运算

  var cache = {};

  function evaluation($control){

    var ast, related;
    var str = $control('key');
    var model = $control('model');
    var parent = $control('parent');

    /**
     * 对变量求值
     */
    function val(variable){

      if (!variable.path.length) {
        return model.get(variable.name, parent);
      } else {
        var key = variable.name + '.' + variable.path.join('.');
        return model.get(key, parent);
      }

    }

    var cacheKey = parent? parent.name + ':' + parent.id + str : str;
    if (cacheKey in cache) {

      ast = cache[cacheKey].ast;
      related = cache[cacheKey].related;

    } else {

      ast = Parse.parse(str);
      related = getRelated(ast, model, parent);
      cache[cacheKey] = { ast: ast, related: related };

    }

    return { 
      val:  expr(ast, val),
      related: related
    };

  }

  /**
   * 获取相关的属性，比如 a.b > c，和[a, c]的变化有关
   */
  function getRelated(ast, model, parent){

    var ret = [];

    if (!ast.operator) {

      if (ast.name) {

        var str = ast.name;

        if (ast.path.length)
          str += '.' + ast.path.join('.');

        ret = ret.concat(model.getRelated(str, parent));
      }

    } else {

      if (ast.l) ret = ret.concat(getRelated(ast.l, model, parent));
      if (ast.r) ret = ret.concat(getRelated(ast.r, model, parent));

    }

    return ret;

  }

  /**
   * 运算结果，和标准的逻辑求值一样
   */
  function expr(ast, val){

    if (!ast.operator) {

      if (ast.name)  {
        return val(ast);
      } else {
        return parseInt(ast);
      }

    } else {

      switch(ast.operator){

        case '&&':
          return expr(ast.l, val) && expr(ast.r, val);
          break;

        case '||':
          return expr(ast.l, val) || expr(ast.r, val);
          break;

        case 'not':
          return !expr(ast.l, val);
          break;

        case '==':
          return expr(ast.l, val) == expr(ast.r, val);
          break;

        case '!=':
          return expr(ast.l, val) != expr(ast.r, val);
          break;

        case '>=':
          return expr(ast.l, val) >= expr(ast.r, val);
          break;

        case '<=':
          return expr(ast.l, val) <= expr(ast.r, val);
          break;

        case '<':
          return expr(ast.l, val) < expr(ast.r, val);
          break;

        case '>':
          return expr(ast.l, val) > expr(ast.r, val);
          break;
      }

    }
  }

  return evaluation;

}, {
  requires: ['./parse']
});

KISSY.add('gallery/bidi/1.0/models',function(S, evaluation){

  "use strict";

  function Model(obj, augment){

    var attributes;

    function Attr(){}

    if (augment) {

      S.augment(Attr, augment);

      attributes = new Attr();
      S.mix(attributes, obj);

    } else {

      attributes = obj;

    }

    this.attributes = attributes;

    this.linkages = {};
    this.lists = {};

    return this;
  }

  S.augment(Model, S.EventTarget, {

    /**
     * @private
     */
    _isFunc: function(key, parent){
      var val;
      if (parent) {
        val = this._getParent(parent)[key];
      } else {
        val = this._getAttr(key);
      }

      return S.isFunction(val);
    },

    setLists: function(key){
      this.lists[key] = true;
    },

    /**
     * get方法，获取key值，默认情况下，直接从数据根节点获取数据，如果parent参数
     * 不为空，则通过parent来查找变量
     * @public
     * @param {string} key 需要查找的变量的key
     * @param {undefined|object} parent key的范围，默认为根节点
     */
    get: function(key, parent){ 

      if (parent) {
        return this._getByParent(key, parent);
      }

      var val = this._getAttr(key);

      if (typeof val == 'function') {
        val = val.call(this);
      }

      if (this.__recode) {
        this.__getter.push(key);
      }

      return val;
    },

    _getAttr: function(key, base){

      var paths = key.split('.');
      var ret = base || this.attributes;

      //$aa.$item.attr
      if (paths.length > 2 && paths[1] === '$item') {
        ret = this.item(paths[0]);
        paths = paths.slice(2);

        if(!ret) return ret;
      }

      S.each(paths, function(path){
        ret = ret[path];
        if (ret === undefined) return false;
      });

      if (key in this.linkages) {

        var link = this.linkages[key];
        var filter = this.item(link);
        var last = paths[0];

        if (filter && filter[last]) {
          filter = filter[last];
          ret = S.filter(ret, function(item){
            return S.indexOf(item.value, filter) > -1;
          });
        } else {
          return undefined;
        }
      }

      return ret;
    },

    /**
     * 获取某个表单所对应的对象，通常，如果是一个select或者radio，一个select对应
     * 的$values有多个，item根据select的$defaultValue所对应的对象
     */
    item: function(key){

      var items = this.get(key).values;
      var val = this.get(key).defaultValue;
      var ret;

      if (!items) return ret;

      S.some(items, function(item){
        if (item.value == val) {
          ret = item;
          return true;
        }
      });

      return ret;

    },
    /**
     * 获取key来查找，parent对象定义了key所处的id和根节点name
     * @private
     */
    _getByParent: function(key, parent){

      var ret;
      if (key && key.indexOf('$root.') === 0) {
        ret = this._getAttr(key.slice(6));
      } else {
        var val = this._getParent(parent);
        ret = key !== null? this._getAttr(key, val): val;
      }

      if (S.isFunction(ret)){
        //如果在list中，函数第一个参数是，list所在的对象
        ret = ret.call(this, parent);
      }

      if (this.__recode) {
        this.__getter.push(parent.name + ':' + parent.id);
      }

      return ret;
    },

    /**
     * @private
     */
    _getParent: function(parent){

      // this.set('xxx', 'seat');
      if (!parent.name || !parent.id) return parent;

      var name = parent.name;
      var o = this.get(name);
      var ret = {};

      S.some(o, function(val){

        if (val['__parent__'].id === parent.id) {
          ret = val;
          return true;
        }

      }, this);

      return ret;
    },

    getRelated: function(key, parent){

      if (this._isFunc(key, parent)) {

        this.__recode = true;
        this.__getter = [];
        this.get(key, parent);
        this.__recode = false;

        return this.__getter.slice();

      } else {

        return parent ? [parent.name + ':' + parent.id] : [key];

      }

    },

    /**
     * return json object of attributes
     */
    toJSON: function(){ 

      var json = {};

      this.__forbidden_set = true;

      S.each(this.attributes, function(val, key){

        if (this.attributes.hasOwnProperty(key)) {
          json[key] = this.get(key);
        }

      }, this); 

      delete this.__forbidden_set;

      return json;
    },

    /**
     * 绑定change:xxx事件封装，直接使用this.on('change:' + xxx)感觉不好，另外支
     * 持传入一个数组，对于多个属性封装，使用数组更方便
     * @param {array|string} key 需要绑定change事件的属性
     * @param {function} fn 回调函数
     * @param {object|undefined} context 执行上下文，可以不填
     * @return this
     */
    change: function(key, fn, context){

      var evt = '';

      if (S.isArray(key)){

        evt = S.map(key, function(name){
          return 'change:' + name + ' add:' + name + ' remove:' + name;
        }).join(' ');

      } else {
        evt = 'change:' + key;
      }

      this.on(evt, fn, context);

      return this;

    },

    /**
     * 赋值方法，通过set，修改属性值，并且，触发事件
     * @param {string} key 属性的key
     * @param {object} value
     * @param {object|undefined} parent 定义parent，在list中需要用到
     * @public
     * @return this
     */
    set: function(key, value, parent){

      // 临时禁止set方法，在toJSON方法调用的时候需要如此
      if (this.__forbidden_set) return;

      if (parent) {
        return this._setByParent(key, value, parent);
      }

      var paths = key.split('.');
      var attr = this.attributes;
      var len = paths.length;

      S.each(paths, function(path, i){

        if (path in attr && i < len - 1) {
          attr = attr[path];
        } else {
          return false;
        }

      });

      var last = paths[len - 1];

      attr[last] = value;

      //如果是list，给每个元素增加一个属性
      if (key in this.lists) this._addToken(key, value);

      this.fire('change:' + paths[0], {path: paths.slice(1), val: value});
      return this;

    },

    //增加parent的标志
    _addToken: function(key, lists){
      S.each(lists, function(list){
        list['__parent__'] = { name: key, id: S.guid('$id') };
      })
    },

    /**
     * 删除集合中的一个元素
     * @param {object} obj 集合元素
     * @public
     * @return this
     */
    remove: function(obj){

      if (this.__forbidden_set) return;

      var parentKey = obj.name;
      var lists = this.get(parentKey);
      var index;

      S.some(lists, function(list, i){
        if (list['__parent__'].id === obj.id){
          index = i;
          return true;
        }
      });

      //删除元素
      lists.splice(index, 1);
      this.fire('remove:' + parentKey, {id: obj.id, index: index});

      return this;
    },

    /**
     * 在list中添加一个元素
     * @param {object} obj 需要加入元素
     * @param {string} key 需要增加的属性
     * @public
     */
    add: function(obj, key){

      if (this.__forbidden_set) return;

      obj['__parent__'] = { id: S.guid('$id'), name: key};
      var lists = this.get(key);

      lists.push(obj);
      this.fire('add:' + key, {obj: obj});

      return this;
    },

    /**
     * @private
     */
    _setByParent: function(key, value, parent){

      var o = this._getParent(parent);
      if (o && key in o) {
        o[key] = value;
      }

      this.fire('change:' + parent.name, { $item: parent.id });
    },

    /**
     * 对表达式求值
     * @return {object} { val: Boolen, related: Array }
     */
    evaluation: function($control){
      return evaluation($control);
    },

    setLinkage: function(key, val){
      this.linkages[key] = val;
      return this;
    }

  });

  return Model;

}, {
  requires: [
    './expression/index',
    'event'
  ]
});

KISSY.add('gallery/bidi/1.0/watch/text',function(S){

  "use strict";

  function add(watch){
    
    watch.add('text', {

      init: function(){

        var $control = this.$control;
        var model = $control('model');
        var key = $control('key');

        var el = $control('el');
        var expr = model.evaluation($control);

        var argv = $control('argv');
        var pipe = argv[0];

        model.change(expr.related, function(){

          var val = model.evaluation($control).val;

          if (pipe && pipe in watch.pipe){
            val = watch.pipe[pipe](val);
          }

          el.html(val);

        }, this)

      },

      beforeReady: function(){

        var $control = this.$control;
        var model = $control('model');
        var val = model.evaluation($control).val || '';
        var argv = $control('argv');
        var pipe = argv[0];

        if (pipe && pipe in watch.pipe){
          val = watch.pipe[pipe](val);
        }

        this.$html = ' id=' + $control('id') + '>' + val + '<!----';
        watch.noEscape[this.$html] = true;

      }

    });

  }

  return add;

});

KISSY.add('gallery/bidi/1.0/watch/class',function(S){

  "use strict";

  return function(watch){

    watch.add('class', function(){

      var $control = this.$control;
      var model = $control('model');
      var key = $control('key');
      var classname = $control('argv')[0];

      var expr = model.evaluation($control);

      model.change(expr.related, change);

      function change(){
        var el = $control('el');
        var fn = model.evaluation($control).val ? 'addClass': 'removeClass';
        el[fn](classname);
      }

      change();

    });

  }

});

KISSY.add('gallery/bidi/1.0/watch/click',function(S){

  "use strict";

  return function(watch){

    watch.add('click', function(){

      var $control = this.$control;
      var model = $control('model');
      var key = $control('key');
      var selector = $control('selector');

      $control('base').delegate('click', selector, function(){
        model.get(key, $control('parent'));
      });

    });

  }

} );

KISSY.add('gallery/bidi/1.0/watch/select',function(S){

  "use strict";

  return function(watch){

    watch.add('select', function(){

      var $control = this.$control;
      var model = $control('model');
      var key = $control('key');
      var el = $control('el');
      var parent = $control('parent');

      var expr = model.evaluation($control);
      el.val(expr.val);

      el.on('change', function(){
        model.set(key, el.val(), parent);
      });

    });

  }

}, {
});

KISSY.add('gallery/bidi/1.0/watch/attr',function(S){

  "use strict";

  return function(watch){

    watch.add('attr', function(){

      var $control = this.$control;
      var model = $control('model');
      var key = $control('key');
      var attrname = $control('argv')[0];

      var expr = model.evaluation($control);

      model.change(expr.related, function(){

        var el = $control('el');
        el.attr(attrname, model.evaluation($control).val);

      });

    });

  }

});

KISSY.add('gallery/bidi/1.0/watch/each',function(S, XTemplate){

  "use strict";

  function add(watch){

    watch.add('linkage', {

      init: function(){


        var $control = this.$control;

        var model = $control('model');
        var key = $control('key');
        var linkage = $control('argv')[0];

        model.change(linkage, function(){

          var fn = $control('fn');
          var el = $control('el');

          var html = new XTemplate(fn);
          var option = {params: [model.get(key)], fn: fn};
          html = html.runtime.option.commands.each([model.get(key)], option);
          el.html(html);

          var paths = key.split('.');

          model.set(paths[0] + '.defaultValue', null);

        });

      },

      beforeReady: function(){

        var $control = this.$control;
        var model = $control('model');
        var key = $control('key');
        var linkage = $control('argv')[0];

        model.setLinkage(key, linkage);

        this.$html = '<span class=xform id=' + $control('id') + '>';

      }

    });

  }

  return add;

}, {
  requires: ['xtemplate']
});

KISSY.add('gallery/bidi/1.0/watch/radio',function(S){

  "use strict";

  return function(watch){

    watch.add('radio', function(){

      var $control = this.$control;
      var model = $control('model');
      var key = $control('key');
      var el = $control('el');

      el.delegate('click', 'input', function(e){

        var target = S.all(e.currentTarget);
        var val = target.val();

        model.set(key, val);

      });

    });

  }

}, {
});

KISSY.add('gallery/bidi/1.0/watch/list',function(S, XTemplate){

  "use strict";

  function add(watch){

    watch.add('list', {

      init: function(){

        var $control = this.$control;
        var self = this;

        var model = $control('model');
        var key = $control('key');

        model.on('remove:' + key, function(e){

          var el = $control('el').children();
          var index = e.index;
          el.item(index).remove();

        });

        model.on('add:' + key, function(e){

          var fn = $control('fn');
          var option = {params: [e.obj], fn: fn};

          var json = model.toJSON();
          json['__name__'] = $control('name');

          var html = option.fn([e.obj, json]).replace(/^>/, '');
          $control('el').append(html);

          $control('view').fire('inited');

        });

        this._bindChange();
      },

      _bindChange: function(){

        var $control = this.$control;
        var model = $control('model');
        var key = $control('key');

        model.change(key, function(e){

          if (e.$item) return;

          var fn = $control('fn');
          var option = {params: [e.val], fn: fn};

          var json = model.toJSON();
          json['__name__'] = $control('name');

          var html = new XTemplate(fn);
          html = html.runtime.option.commands.each([e.val, json], option);

          $control('el').html(html);
          $control('view').fire('inited');

        });

      },

      beforeReady: function(){
        var $control = this.$control();
        var model = $control.model;
        model.setLists($control.key);
      }

    });

  }

  return add;

}, {
  requires: ['xtemplate']
});

KISSY.add('gallery/bidi/1.0/watch/render',function(S, XTemplate){

  "use strict";

  function add(watch){

    watch.add('render', {

      init: function(){

        var $control = this.$control;
        var model = $control('model');
        var key = $control('key');

        model.change(key, function(e){

          if (e.$item) return;

          var fn = $control('fn');
          var option = {params: [e.val], fn: fn};

          var json = model.toJSON();
          json['__name__'] = $control('name');

          var html = option.fn([e.val, json]);

          $control('el').html(html);
          $control('view').fire('inited');

        });

      },

      beforeReady: function(){
        //var $control = this.$control();
        //var model = $control.model;
        //model.setLists($control.key);
      }

    });

  }

  return add;

}, {
  requires: ['xtemplate']
});

KISSY.add('gallery/bidi/1.0/watch/value',function(S){

  "use strict";

  function add(watch){

    watch.add('value', {

      init: function(){

        var $control = this.$control();
        S.mix(this, $control);
        this._render();

      },

      beforeReady: function(){
        var $control = this.$control;
        var key = $control('key');
        var model = $control('model');
        var val = model.get(key);

        this.$html = ' value= ' + val + ' id=' + $control('id') + ' ';
      },

      _render: function(){

        var el = this.el;
        var type = el.attr('type') || 'input';
        var model = this.model;
        var key = this.key;

        if (type == 'radio') {
          this._bindRadio();
        } else {
          //el.val(model.get(key));
          this._bindEvent();
        }

      },

      _bindRadio: function(){

        var el = this.el;
        var model = this.model;
        var base = this.base;
        var name = el.attr('name');
        var key = this.key;

        base.delegate('click', 'input', function(e){

          var target = e.currentTarget;

          if (target.type == 'radio' && target.name == name) {
            var val = el.attr('checked');
            model.set(key, val);
          }

        });

        model.change(key, function(){
          el.attr('checked', model.get(key));
        });

      },

      _bindEvent: function(){

        var el = this.el;
        var model = this.model;
        var key = this.key;

        el.on('keyup', function(){

          var val = el.val();
          model.set(key, val);

        });

        model.change(key, function(){
          el.val(model.get(key));
        });

      }

    });

  }

  return add;

}, {
});

KISSY.add('gallery/bidi/1.0/watch/index',function(S){

  "use strict";

  var watchers = {};
  var watch = {}

  watch.noEscape = {};

  var esc = S.escapeHTML;
  //重写escapeHtml方法，增加白名单
  S.escapeHTML = function(s){
    return s in watch.noEscape ? s: esc(s);
  };

  watch.add = function(name, watcher){

    if (name in watchers) {
      S.error(name + ' has be add before');
    }

    if (S.isFunction(watcher)) {
      watcher = { init: watcher };
    }

    /**
     * cfg: el, key, model, base
     */
    watchers[name] = function(cfg){

      var $control = {};

      S.mix($control, cfg);

      this.$control = function(key, val){

        // $control() return all varialbe accessible
        if (!key) return S.mix($control, {});

        // $control(key)
        if (!val) return $control[key]; 
        
        //一次性写入
        // $control(key, val)
        if (!(key in $control)) $control[key] = val;

      };

      this.beforeReady && this.beforeReady();

      this.on('ready', this.init, this);

    };

    S.augment(watchers[name], S.EventTarget, watcher);

  };

  watch.get = function(name){
    return watchers[name];
  };

  watch.pipe = {};

  S.each(arguments, function(fn, i){
    if (i) fn(watch);
  });

  return watch;

}, {
  requires: [
    './text',
    './class',
    './click',
    './select',
    './attr',
    './each',
    './radio',
    './list',
    './render',
    './value'
  ]
});

KISSY.add('gallery/bidi/1.0/views',function(S, Event, XTemplate, Watch){

  "use strict";

  function View(name, model){

    this.model = model;
    this.name = name;

  }

  S.augment(View, S.EventTarget, {

    setEl: function(el){

      this.el = el;
      this.template = new XTemplate(el.all('script').html());

      return this;

    },

    render: function(){

      var json = this.model.toJSON();
      json['__name__'] = this.name;

      var html = this.template.render(json);
      html = html.replace(/>\s+>>><<</g, '');
      this.el.html(html);

      this.fire('inited');

      return this;
    },

    watch: function(params, fn){

      var who = params[0];
      var key = params[1];
      var watcher = Watch.get(who);
      var id = params.id || 'bidi-' + this.name + '-' + S.guid();
      var selector = '#' + id;
      var argv = params.slice(2);
      var html = ' id=' + id + ' ';
      var meta = params.meta;

      if (watcher) {

        var w = new watcher({
          // watcher所对应的dom id选择器
          selector: selector,
          // 如果是list下一个元素，parent记录了父元素相关信息
          parent: meta,
          // id选择器对应的id，没有符号"#"
          id: id,
          // 绑定的数据对象键值
          key: key, 
          // 数据对象，model
          model: this.model,
          // view对应的NodeList
          base: this.el,
          // XTemplate执行函数，只在block语法下需要，比如linkage、list
          fn: fn,
          // 其他参数，{{watch "text: key: argv0: argv1}}
          argv: argv,
          name: this.name,
          view: this
        });

        var _init = function(){
          // dom ready
          w.$control('el', this.el.all(selector));
          w.fire('ready');

          this.detach('inited', _init);
        }

        this.on('inited', _init);

        html = w.$html || html;

      } else {

        S.log('watcher ' + who + ' is not defined!');

      }

      return {id: id, html: html};
    }

  });

  return View;

}, {
  requires: [
    'event',
    'xtemplate',
    './watch/index'
  ]
});

/**
 * @fileoverview 请修改组件描述
 * @author hanwen.sah<hanwen.sah@taobao.com>
 * @module bidi
 **/
KISSY.add('gallery/bidi/1.0/index',function (S, Node, Base, XTemplate, Model, View, Watcher){

  "use strict";

  var EMPTY = '';
  var $ = Node.all;
  var Views = {};
  //记录list下面元素所对应的parent
  var META = '__parent__';
  //记录view视图的名字
  var NAME = '__name__';

  /**
   * 处理双向绑定分发的函数, watch自定义命令，注入到xtemplate执行过程中
   */
  function watch(scopes, option){

    var id;
    var len = scopes.length - 1;
    var name = scopes[len][NAME];
    var ret;
    var meta = scopes[0][META];

    S.each(option.params, function(param, i){

      var params = S.map(param.split(':'), S.trim);
      if (meta) params.meta = meta;

      if (!option.fn) {

        if (id) {

          params.id = id;
          Views[name].watch(params);

        } else {

          var o = Views[name].watch(params);
          id = o.id;
          ret = o.html;

        }

      } else {

        if (!id) {

          var o = Views[name].watch(params, option.fn);
          id = o.id;
          var fn = params[0];

          if (fn in Block) {
            ret = Block[fn](scopes, option, params, name, o.html);
          } else {
            S.log('watch block command no support ' + fn);
          }

        } else {

          params.id = id;
          Views[name].watch(params);

        }

      }

    });

    return ret;
  }

  // 块级语法支持，需要一些特殊的处理
  var Block = {

    linkage: function(scopes, option, params, name, html){

      html = html || '';
      var model = Views[name].model;

      //重新计算，这时候model的value会有改变
      scopes[0]['$$linkage'] = model.get(params[1]);

      //调用XTemplate的each命令
      option.params[0] = scopes[0]['$$linkage'];
      html += option.commands.each(scopes, option);

      delete scopes['$$linkage'];

      html += '</span>';

      return html;

    },

    render: function(scopes, option, params, name, html){

      var model = Views[name].model;
      var len = scopes.length - 1;

      option.params[0] = scopes[0][params[1]];

      var param0 = option.params[0];
      var opScopes = [param0, scopes];

      var buf = option.fn(opScopes).replace(/^>/, '');

      return ' >>><<<' + html + '>' + buf;


    },

    list: function(scopes, option, params, name, html){

      var model = Views[name].model;
      var len = scopes.length - 1;

      option.params[0] = scopes[0][params[1]];

      var param0 = option.params[0];
      var opScopes = [0, 0].concat(scopes);
      var xcount = param0.length;

      var buf = '';

      for (var xindex = 0; xindex < xcount; xindex++) {
        // two more variable scope for array looping
        opScopes[0] = param0[xindex];

        if (!opScopes[0][META]) {
          opScopes[0][META] = { id: S.guid('$id'), name: params[1]};
        }

        opScopes[1] = {
          xcount: xcount,
          xindex: xindex
        };
        buf += option.fn(opScopes).replace(/^>/, '');
      }

      return ' >>><<<' + html + '>' + buf;

    },

    with: function(scopes, option, params, name, html){

      var model = Views[name].model;
      var len = scopes.length - 1;

      option.params[0] = scopes[0][params[1]];

      var param0 = option.params[0];
      var opScopes = [param0].concat(scopes);

      var buf = option.fn(opScopes).replace(/^>/, '');

      return ' >>><<<' + html + '>' + buf;

    },

  };

  // 缓存已经注册到XTemplate中的命令，避免重复执行
  var commands = {};
  // for Bidi.active function
  function addCommand(name){

    if (name in commands) return;

    var fn = function(scopes, option){
      option.params[0] = name + ':' + option.params[0];
      return watch(scopes, option);
    }

    commands[name] = fn;

  }

  var Bidi = {

    /**
     * 激活命令，比如Bidi.active('text'), 那么可以在模板中写 
     * {{text "key"}} == {{watch "text: key"}}
     * @param {string|array} name 需要激活的命令，注册到XTemplate的自定义命令中
     * @static
     */
    active: function(name){

      if (S.isArray(name)){

        S.each(name, addCommand);

      } else {

        addCommand(name);

      }

    },

    xbind: function(name, obj, augment){

      Views[name] = new View(name, new Model(obj, augment));
      return Views[name];

    },

    init: function(){

      $(".bidi-viewer").each(function(el){

        var name = el.attr('data-view');
        var view = Views[name].setEl(el);

        //添加命令
        view.template.addCommand('watch', watch);
        S.each(commands, function(fn, cmd){
          view.template.addCommand(cmd, fn);
        });

        view.render();
      });

    },

    // add custom watcher
    add: function(name, obj){
      Watcher.add(name, obj);
    },

    // add pipe function
    pipe: function(name, fn){
      Watcher.pipe[name] = fn;
    }

  };

  return Bidi;

}, {
  requires:[
    'node', 
    'base',
    'xtemplate',
    './models',
    './views',
    './watch/index'
  ]
});

